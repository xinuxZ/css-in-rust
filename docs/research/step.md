



ç”¨æˆ·è¯¢é—® CSS-in-Rust è‡ªç ”æ–¹æ¡ˆçš„å…·ä½“æ€è·¯å’Œå®ç°è·¯å¾„ã€‚ä½œä¸ºæ—…æ¸¸ç”µå•†æ¶æ„å¸ˆï¼Œæˆ‘éœ€è¦æ·±åº¦åˆ†æè¿™ä¸ªæŠ€æœ¯æ–¹æ¡ˆçš„è®¾è®¡æ€è·¯ã€æ ¸å¿ƒæ¶æ„ã€å®ç°ç»†èŠ‚å’ŒæŠ€æœ¯æŒ‘æˆ˜ï¼Œä¸º Ant Design Dioxus é¡¹ç›®æä¾›ä¸“ä¸šçš„æŠ€æœ¯æŒ‡å¯¼ã€‚


toolName: run_mcp

status: success

mcp: mcp.config.usrlocalmcp.sequential-thinking sequentialthinking [object Object]
 {"content":[{"type":"text","text":"{\n  \"thoughtNumber\": 1,\n  \"totalThoughts\": 10,\n  \"nextThoughtNeeded\": true,\n  \"branches\": [],\n  \"thoughtHistoryLength\": 43\n}"}],"isError":null}




toolName: run_mcp

status: success

mcp: mcp.config.usrlocalmcp.sequential-thinking sequentialthinking [object Object]
 {"content":[{"type":"text","text":"{\n  \"thoughtNumber\": 2,\n  \"totalThoughts\": 10,\n  \"nextThoughtNeeded\": true,\n  \"branches\": [],\n  \"thoughtHistoryLength\": 44\n}"}],"isError":null}




toolName: run_mcp

status: success

mcp: mcp.config.usrlocalmcp.sequential-thinking sequentialthinking [object Object]
 {"content":[{"type":"text","text":"{\n  \"thoughtNumber\": 3,\n  \"totalThoughts\": 10,\n  \"nextThoughtNeeded\": true,\n  \"branches\": [],\n  \"thoughtHistoryLength\": 45\n}"}],"isError":null}




toolName: run_mcp

status: success

mcp: mcp.config.usrlocalmcp.sequential-thinking sequentialthinking [object Object]
 {"content":[{"type":"text","text":"{\n  \"thoughtNumber\": 4,\n  \"totalThoughts\": 10,\n  \"nextThoughtNeeded\": true,\n  \"branches\": [],\n  \"thoughtHistoryLength\": 46\n}"}],"isError":null}




toolName: run_mcp

status: success

mcp: mcp.config.usrlocalmcp.sequential-thinking sequentialthinking [object Object]
 {"content":[{"type":"text","text":"{\n  \"thoughtNumber\": 5,\n  \"totalThoughts\": 10,\n  \"nextThoughtNeeded\": true,\n  \"branches\": [],\n  \"thoughtHistoryLength\": 47\n}"}],"isError":null}




toolName: run_mcp

status: success

mcp: mcp.config.usrlocalmcp.sequential-thinking sequentialthinking [object Object]
 {"content":[{"type":"text","text":"{\n  \"thoughtNumber\": 6,\n  \"totalThoughts\": 10,\n  \"nextThoughtNeeded\": true,\n  \"branches\": [],\n  \"thoughtHistoryLength\": 48\n}"}],"isError":null}




toolName: run_mcp

status: success

mcp: mcp.config.usrlocalmcp.sequential-thinking sequentialthinking [object Object]
 {"content":[{"type":"text","text":"{\n  \"thoughtNumber\": 7,\n  \"totalThoughts\": 10,\n  \"nextThoughtNeeded\": true,\n  \"branches\": [],\n  \"thoughtHistoryLength\": 49\n}"}],"isError":null}




toolName: run_mcp

status: success

mcp: mcp.config.usrlocalmcp.sequential-thinking sequentialthinking [object Object]
 {"content":[{"type":"text","text":"{\n  \"thoughtNumber\": 8,\n  \"totalThoughts\": 10,\n  \"nextThoughtNeeded\": true,\n  \"branches\": [],\n  \"thoughtHistoryLength\": 50\n}"}],"isError":null}




toolName: run_mcp

status: success

mcp: mcp.config.usrlocalmcp.sequential-thinking sequentialthinking [object Object]
 {"content":[{"type":"text","text":"{\n  \"thoughtNumber\": 9,\n  \"totalThoughts\": 10,\n  \"nextThoughtNeeded\": true,\n  \"branches\": [],\n  \"thoughtHistoryLength\": 51\n}"}],"isError":null}




toolName: run_mcp

status: success

mcp: mcp.config.usrlocalmcp.sequential-thinking sequentialthinking [object Object]
 {"content":[{"type":"text","text":"{\n  \"thoughtNumber\": 10,\n  \"totalThoughts\": 10,\n  \"nextThoughtNeeded\": false,\n  \"branches\": [],\n  \"thoughtHistoryLength\": 52\n}"}],"isError":null}

# CSS-in-Rust è‡ªç ”æ–¹æ¡ˆæ·±åº¦æŠ€æœ¯åˆ†æ

ä½œä¸ºæ—…æ¸¸ç”µå•†è¡Œä¸šçš„èµ„æ·±æ¶æ„å¸ˆï¼Œæˆ‘ä¸ºæ‚¨æ·±å…¥åˆ†æ CSS-in-Rust è‡ªç ”æ–¹æ¡ˆçš„æ ¸å¿ƒæ€è·¯å’Œå®ç°è·¯å¾„ã€‚

## ğŸ¯ æ ¸å¿ƒè®¾è®¡ç†å¿µ

CSS-in-Rust è‡ªç ”æ–¹æ¡ˆçš„æ ¸å¿ƒç›®æ ‡æ˜¯åœ¨ Rust ç”Ÿæ€ä¸­å®ç°ç±»ä¼¼ CSS-in-JS çš„èƒ½åŠ›ï¼ŒåŒæ—¶å……åˆ†åˆ©ç”¨ Rust çš„ç±»å‹å®‰å…¨ã€æ€§èƒ½ä¼˜åŠ¿å’Œç¼–è¯‘æ—¶ä¼˜åŒ–ç‰¹æ€§ã€‚

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„è®¾è®¡

### 1. æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å¼€å‘æ—¶ DSL    â”‚â”€â”€â”€â–¶â”‚   ç¼–è¯‘æ—¶å¤„ç†    â”‚â”€â”€â”€â–¶â”‚   è¿è¡Œæ—¶ç³»ç»Ÿ    â”‚
â”‚  (style! å®)   â”‚    â”‚  (å®å±•å¼€+ä¼˜åŒ–)  â”‚    â”‚  (æ ·å¼æ³¨å…¥)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â–¼                       â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   è¯­æ³•è§£æ      â”‚    â”‚   æ ·å¼ç”Ÿæˆ      â”‚    â”‚   DOM æ“ä½œ      â”‚
â”‚   ç±»å‹æ£€æŸ¥      â”‚    â”‚   ä¼˜åŒ–å‹ç¼©      â”‚    â”‚   ç¼“å­˜ç®¡ç†      â”‚
â”‚   æ™ºèƒ½æç¤º      â”‚    â”‚   å“ˆå¸Œç”Ÿæˆ      â”‚    â”‚   çƒ­æ›´æ–°        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. æ ¸å¿ƒæ¨¡å—è®¾è®¡

```rust
// é¡¹ç›®ç»“æ„
antd-styles/
â”œâ”€â”€ antd-styles-macro/     // å®å®šä¹‰å’Œç¼–è¯‘æ—¶å¤„ç†
â”œâ”€â”€ antd-styles-runtime/   // è¿è¡Œæ—¶æ ·å¼ç®¡ç†
â”œâ”€â”€ antd-styles-theme/     // ä¸»é¢˜ç³»ç»Ÿ
â”œâ”€â”€ antd-styles-tokens/    // Design Token å®šä¹‰
â””â”€â”€ antd-styles-tools/     // å¼€å‘å·¥å…·
```

## ğŸ’¡ æ ¸å¿ƒæŠ€æœ¯å®ç°

### 1. æ ·å¼å®šä¹‰ DSL (Domain Specific Language)

#### å®ç³»ç»Ÿè®¾è®¡
```rust
// antd-styles-macro/src/lib.rs
use proc_macro::TokenStream;
use syn::{parse_macro_input, LitStr};
use quote::quote;

/// æ ¸å¿ƒæ ·å¼å®ï¼Œæ”¯æŒç±»ä¼¼ CSS çš„è¯­æ³•
#[proc_macro]
pub fn style(input: TokenStream) -> TokenStream {
    let css_input = parse_macro_input!(input as CssInput);

    // è§£æ CSS è¯­æ³•æ ‘
    let parsed_styles = parse_css_syntax(&css_input);

    // ç”Ÿæˆå”¯ä¸€ç±»å
    let class_name = generate_class_name(&parsed_styles);

    // åˆ†ç¦»é™æ€å’ŒåŠ¨æ€æ ·å¼
    let (static_styles, dynamic_styles) = separate_styles(&parsed_styles);

    // ç”Ÿæˆè¿è¡Œæ—¶ä»£ç 
    let generated_code = quote! {
        {
            use antd_styles_runtime::StyleManager;

            // æ³¨å†Œé™æ€æ ·å¼
            StyleManager::register_static_style(
                #class_name,
                #static_styles
            );

            // å¤„ç†åŠ¨æ€æ ·å¼
            let dynamic_css = format!(#dynamic_styles);
            StyleManager::apply_dynamic_style(#class_name, &dynamic_css);

            #class_name
        }
    };

    generated_code.into()
}

/// CSS è¯­æ³•è§£æå™¨
struct CssParser {
    // CSS å±æ€§è§£æ
    // åµŒå¥—é€‰æ‹©å™¨å¤„ç†
    // ä¼ªç±»å’Œä¼ªå…ƒç´ æ”¯æŒ
    // åª’ä½“æŸ¥è¯¢å¤„ç†
}

/// æ ·å¼è¯­æ³•æ ‘
#[derive(Debug, Clone)]
struct StyleAst {
    properties: Vec<CssProperty>,
    nested_rules: Vec<NestedRule>,
    media_queries: Vec<MediaQuery>,
}
```

#### è¯­æ³•ç¤ºä¾‹
```rust
// ä½¿ç”¨ç¤ºä¾‹
let button_styles = style! {
    // åŸºç¡€æ ·å¼
    display: inline-block;
    padding: {theme.spacing.md};
    background-color: {theme.colors.primary};
    border: 1px solid {theme.colors.primary};
    border-radius: {theme.border_radius};
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;

    // ä¼ªç±»
    &:hover {
        background-color: {theme.colors.primary_hover};
        transform: translateY(-1px);
    }

    &:active {
        transform: translateY(0);
    }

    &:disabled {
        opacity: 0.6;
        cursor: not-allowed;
    }

    // åµŒå¥—é€‰æ‹©å™¨
    .icon {
        margin-right: 8px;
        font-size: {theme.font_size.sm};
    }

    // åª’ä½“æŸ¥è¯¢
    @media (max-width: 768px) {
        padding: {theme.spacing.sm};
        font-size: {theme.font_size.sm};
    }

    // æ¡ä»¶æ ·å¼
    {if props.loading {
        "opacity: 0.7; pointer-events: none;"
    } else {
        ""
    }}
};
```

### 2. è¿è¡Œæ—¶æ ·å¼ç®¡ç†ç³»ç»Ÿ

```rust
// antd-styles-runtime/src/lib.rs
use std::collections::HashMap;
use web_sys::{Document, Element, HtmlStyleElement};
use wasm_bindgen::JsCast;

/// å…¨å±€æ ·å¼ç®¡ç†å™¨
pub struct StyleManager {
    // æ ·å¼ç¼“å­˜
    static_styles: HashMap<String, String>,
    dynamic_styles: HashMap<String, String>,

    // DOM å…ƒç´ å¼•ç”¨
    style_element: Option<HtmlStyleElement>,

    // æ€§èƒ½ä¼˜åŒ–
    style_cache: HashMap<String, String>,
    dirty_styles: HashSet<String>,
}

impl StyleManager {
    /// åˆå§‹åŒ–æ ·å¼ç®¡ç†å™¨
    pub fn new() -> Self {
        let window = web_sys::window().unwrap();
        let document = window.document().unwrap();

        // åˆ›å»ºæ ·å¼å…ƒç´ 
        let style_element = document
            .create_element("style")
            .unwrap()
            .dyn_into::<HtmlStyleElement>()
            .unwrap();

        style_element.set_attribute("data-antd-styles", "").unwrap();

        document
            .head()
            .unwrap()
            .append_child(&style_element)
            .unwrap();

        Self {
            static_styles: HashMap::new(),
            dynamic_styles: HashMap::new(),
            style_element: Some(style_element),
            style_cache: HashMap::new(),
            dirty_styles: HashSet::new(),
        }
    }

    /// æ³¨å†Œé™æ€æ ·å¼
    pub fn register_static_style(&mut self, class_name: &str, css: &str) {
        if !self.static_styles.contains_key(class_name) {
            self.static_styles.insert(class_name.to_string(), css.to_string());
            self.dirty_styles.insert(class_name.to_string());
        }
    }

    /// åº”ç”¨åŠ¨æ€æ ·å¼
    pub fn apply_dynamic_style(&mut self, class_name: &str, css: &str) {
        let current_css = self.dynamic_styles.get(class_name);

        if current_css.map_or(true, |current| current != css) {
            self.dynamic_styles.insert(class_name.to_string(), css.to_string());
            self.dirty_styles.insert(class_name.to_string());
        }
    }

    /// æ‰¹é‡æ›´æ–°æ ·å¼åˆ° DOM
    pub fn flush_styles(&mut self) {
        if self.dirty_styles.is_empty() {
            return;
        }

        let mut combined_css = String::new();

        // åˆå¹¶æ‰€æœ‰æ ·å¼
        for class_name in &self.dirty_styles {
            if let Some(static_css) = self.static_styles.get(class_name) {
                combined_css.push_str(&format!(".{} {{ {} }}", class_name, static_css));
            }

            if let Some(dynamic_css) = self.dynamic_styles.get(class_name) {
                combined_css.push_str(&format!(".{} {{ {} }}", class_name, dynamic_css));
            }
        }

        // æ›´æ–° DOM
        if let Some(style_element) = &self.style_element {
            style_element.set_inner_html(&combined_css);
        }

        self.dirty_styles.clear();
    }

    /// æ ·å¼ç¼“å­˜å’Œä¼˜åŒ–
    pub fn get_cached_style(&self, key: &str) -> Option<&String> {
        self.style_cache.get(key)
    }

    pub fn cache_style(&mut self, key: String, css: String) {
        self.style_cache.insert(key, css);
    }
}

/// å…¨å±€æ ·å¼ç®¡ç†å™¨å®ä¾‹
use once_cell::sync::Lazy;
static STYLE_MANAGER: Lazy<std::sync::Mutex<StyleManager>> =
    Lazy::new(|| std::sync::Mutex::new(StyleManager::new()));

/// å…¬å…± API
pub fn register_static_style(class_name: &str, css: &str) {
    STYLE_MANAGER.lock().unwrap().register_static_style(class_name, css);
}

pub fn apply_dynamic_style(class_name: &str, css: &str) {
    STYLE_MANAGER.lock().unwrap().apply_dynamic_style(class_name, css);
}

pub fn flush_styles() {
    STYLE_MANAGER.lock().unwrap().flush_styles();
}
```

### 3. ä¸»é¢˜ç³»ç»Ÿè®¾è®¡

```rust
// antd-styles-theme/src/lib.rs
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Design Token ç³»ç»Ÿ
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DesignTokens {
    pub colors: ColorTokens,
    pub spacing: SpacingTokens,
    pub typography: TypographyTokens,
    pub shadows: ShadowTokens,
    pub borders: BorderTokens,
    pub motion: MotionTokens,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ColorTokens {
    // ä¸»è‰²ç³»
    pub primary: String,
    pub primary_hover: String,
    pub primary_active: String,
    pub primary_disabled: String,

    // åŠŸèƒ½è‰²
    pub success: String,
    pub warning: String,
    pub error: String,
    pub info: String,

    // ä¸­æ€§è‰²
    pub text_primary: String,
    pub text_secondary: String,
    pub text_disabled: String,
    pub border: String,
    pub background: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SpacingTokens {
    pub xs: String,   // 4px
    pub sm: String,   // 8px
    pub md: String,   // 16px
    pub lg: String,   // 24px
    pub xl: String,   // 32px
    pub xxl: String,  // 48px
}

/// ä¸»é¢˜ä¸Šä¸‹æ–‡
#[derive(Debug, Clone)]
pub struct Theme {
    pub tokens: DesignTokens,
    pub component_tokens: HashMap<String, ComponentTokens>,
    pub algorithm: ThemeAlgorithm,
}

/// ç»„ä»¶çº§åˆ«çš„ Token
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComponentTokens {
    pub button: ButtonTokens,
    pub input: InputTokens,
    pub table: TableTokens,
    // ... å…¶ä»–ç»„ä»¶
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ButtonTokens {
    pub height: HashMap<String, String>,      // small, medium, large
    pub padding: HashMap<String, String>,
    pub font_size: HashMap<String, String>,
    pub border_radius: String,
}

/// ä¸»é¢˜ç®—æ³•ï¼ˆç”¨äºç”Ÿæˆè¡ç”Ÿé¢œè‰²ï¼‰
#[derive(Debug, Clone)]
pub enum ThemeAlgorithm {
    Default,
    Dark,
    Compact,
    Custom(Box<dyn Fn(&DesignTokens) -> DesignTokens>),
}

impl Theme {
    /// åˆ›å»ºé»˜è®¤ä¸»é¢˜
    pub fn default() -> Self {
        Self {
            tokens: DesignTokens::default(),
            component_tokens: HashMap::new(),
            algorithm: ThemeAlgorithm::Default,
        }
    }

    /// åˆ›å»ºæš—è‰²ä¸»é¢˜
    pub fn dark() -> Self {
        let mut theme = Self::default();
        theme.algorithm = ThemeAlgorithm::Dark;
        theme.tokens = theme.apply_algorithm();
        theme
    }

    /// åº”ç”¨ä¸»é¢˜ç®—æ³•
    fn apply_algorithm(&self) -> DesignTokens {
        match &self.algorithm {
            ThemeAlgorithm::Default => self.tokens.clone(),
            ThemeAlgorithm::Dark => self.generate_dark_tokens(),
            ThemeAlgorithm::Compact => self.generate_compact_tokens(),
            ThemeAlgorithm::Custom(func) => func(&self.tokens),
        }
    }

    /// ç”Ÿæˆæš—è‰²ä¸»é¢˜ Token
    fn generate_dark_tokens(&self) -> DesignTokens {
        let mut tokens = self.tokens.clone();

        // åè½¬é¢œè‰²
        tokens.colors.background = "#141414".to_string();
        tokens.colors.text_primary = "rgba(255, 255, 255, 0.85)".to_string();
        tokens.colors.text_secondary = "rgba(255, 255, 255, 0.65)".to_string();
        tokens.colors.border = "#434343".to_string();

        tokens
    }

    /// ç”Ÿæˆç´§å‡‘ä¸»é¢˜ Token
    fn generate_compact_tokens(&self) -> DesignTokens {
        let mut tokens = self.tokens.clone();

        // å‡å°é—´è·
        tokens.spacing.xs = "2px".to_string();
        tokens.spacing.sm = "4px".to_string();
        tokens.spacing.md = "8px".to_string();
        tokens.spacing.lg = "12px".to_string();

        tokens
    }
}

/// Dioxus ä¸»é¢˜ Hook
use dioxus::prelude::*;

/// ä¸»é¢˜æä¾›è€…ç»„ä»¶
#[component]
pub fn ThemeProvider(theme: Theme, children: Element) -> Element {
    use_context_provider(|| theme);

    rsx! {
        {children}
    }
}

/// ä½¿ç”¨ä¸»é¢˜çš„ Hook
pub fn use_theme() -> Theme {
    use_context::<Theme>()
}

/// ä½¿ç”¨ Token çš„ Hook
pub fn use_token() -> DesignTokens {
    let theme = use_theme();
    theme.tokens
}
```

### 4. æ ·å¼ç»„åˆå’Œå¤ç”¨ç³»ç»Ÿ

```rust
// antd-styles-runtime/src/styled.rs

/// æ ·å¼åŒ–ç»„ä»¶å®
#[macro_export]
macro_rules! styled_component {
    ($component:ident, $styles:expr) => {
        #[component]
        pub fn $component(props: ComponentProps) -> Element {
            let theme = use_theme();
            let class_name = $styles(&theme, &props);

            rsx! {
                div {
                    class: "{class_name}",
                    ..props.attributes,
                    {props.children}
                }
            }
        }
    };
}

/// æ ·å¼æ··åˆå™¨
pub struct StyleMixin {
    css: String,
}

impl StyleMixin {
    pub fn new(css: &str) -> Self {
        Self {
            css: css.to_string(),
        }
    }

    pub fn combine(mixins: Vec<StyleMixin>) -> String {
        mixins.into_iter()
            .map(|mixin| mixin.css)
            .collect::<Vec<_>>()
            .join(" ")
    }
}

/// å¸¸ç”¨æ ·å¼æ··åˆå™¨
pub mod mixins {
    use super::*;

    /// æ¸…é™¤æµ®åŠ¨
    pub fn clearfix() -> StyleMixin {
        StyleMixin::new(
            "&::after { content: ''; display: table; clear: both; }"
        )
    }

    /// æ–‡æœ¬çœç•¥
    pub fn text_ellipsis() -> StyleMixin {
        StyleMixin::new(
            "overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"
        )
    }

    /// å±…ä¸­å¯¹é½
    pub fn center_flex() -> StyleMixin {
        StyleMixin::new(
            "display: flex; align-items: center; justify-content: center;"
        )
    }

    /// å“åº”å¼éšè—
    pub fn responsive_hide(breakpoint: &str) -> StyleMixin {
        StyleMixin::new(&format!(
            "@media (max-width: {}) {{ display: none; }}",
            breakpoint
        ))
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
use antd_styles::*;

styled_component!(StyledButton, |theme: &Theme, props: &ButtonProps| {
    let base_styles = style! {
        display: inline-block;
        padding: {theme.tokens.spacing.md};
        background-color: {theme.tokens.colors.primary};
        border: none;
        border-radius: 4px;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;

        &:hover {
            background-color: {theme.tokens.colors.primary_hover};
        }
    };

    let size_styles = match props.size {
        ButtonSize::Small => style! {
            padding: {theme.tokens.spacing.sm};
            font-size: 12px;
        },
        ButtonSize::Large => style! {
            padding: {theme.tokens.spacing.lg};
            font-size: 16px;
        },
        _ => String::new(),
    };

    format!("{} {}", base_styles, size_styles)
});
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. ç¼–è¯‘æ—¶ä¼˜åŒ–

```rust
// æ ·å¼é¢„è®¡ç®—å’Œä¼˜åŒ–
pub struct StyleOptimizer {
    // æ ·å¼å»é‡
    deduplication: HashMap<String, String>,

    // æ ·å¼å‹ç¼©
    minification: bool,

    // æ­»ä»£ç æ¶ˆé™¤
    tree_shaking: bool,
}

impl StyleOptimizer {
    /// æ ·å¼å»é‡
    pub fn deduplicate_styles(&mut self, styles: Vec<String>) -> Vec<String> {
        let mut unique_styles = Vec::new();
        let mut seen = HashSet::new();

        for style in styles {
            let hash = self.calculate_style_hash(&style);
            if !seen.contains(&hash) {
                seen.insert(hash);
                unique_styles.push(style);
            }
        }

        unique_styles
    }

    /// CSS å‹ç¼©
    pub fn minify_css(&self, css: &str) -> String {
        css.lines()
            .map(|line| line.trim())
            .filter(|line| !line.is_empty() && !line.starts_with("//"))
            .collect::<Vec<_>>()
            .join(" ")
            .replace("; ", ";")
            .replace(": ", ":")
            .replace(" {", "{")
            .replace("} ", "}")
    }

    /// è®¡ç®—æ ·å¼å“ˆå¸Œ
    fn calculate_style_hash(&self, style: &str) -> u64 {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};

        let mut hasher = DefaultHasher::new();
        style.hash(&mut hasher);
        hasher.finish()
    }
}
```

### 2. è¿è¡Œæ—¶ä¼˜åŒ–

```rust
// æ ·å¼ç¼“å­˜å’Œå¢é‡æ›´æ–°
pub struct StyleCache {
    // LRU ç¼“å­˜
    cache: lru::LruCache<String, String>,

    // æ ·å¼ç‰ˆæœ¬æ§åˆ¶
    versions: HashMap<String, u32>,

    // æ‰¹é‡æ›´æ–°é˜Ÿåˆ—
    update_queue: Vec<StyleUpdate>,
}

#[derive(Debug)]
struct StyleUpdate {
    class_name: String,
    css: String,
    priority: UpdatePriority,
}

#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
enum UpdatePriority {
    Low,
    Normal,
    High,
    Critical,
}

impl StyleCache {
    /// æ‰¹é‡å¤„ç†æ ·å¼æ›´æ–°
    pub fn process_updates(&mut self) {
        // æŒ‰ä¼˜å…ˆçº§æ’åº
        self.update_queue.sort_by_key(|update| update.priority);

        // æ‰¹é‡åº”ç”¨æ›´æ–°
        let mut batch_css = String::new();

        for update in self.update_queue.drain(..) {
            if self.should_update(&update.class_name, &update.css) {
                batch_css.push_str(&format!(
                    ".{} {{ {} }}",
                    update.class_name,
                    update.css
                ));

                self.cache.put(update.class_name.clone(), update.css);
            }
        }

        if !batch_css.is_empty() {
            self.apply_batch_styles(&batch_css);
        }
    }

    /// æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°
    fn should_update(&self, class_name: &str, css: &str) -> bool {
        match self.cache.peek(class_name) {
            Some(cached_css) => cached_css != css,
            None => true,
        }
    }

    /// åº”ç”¨æ‰¹é‡æ ·å¼
    fn apply_batch_styles(&self, css: &str) {
        // ä½¿ç”¨ requestAnimationFrame ä¼˜åŒ– DOM æ›´æ–°
        let closure = Closure::wrap(Box::new(move || {
            if let Some(style_element) = get_style_element() {
                style_element.set_inner_html(css);
            }
        }) as Box<dyn FnMut()>);

        web_sys::window()
            .unwrap()
            .request_animation_frame(closure.as_ref().unchecked_ref())
            .unwrap();

        closure.forget();
    }
}
```

## ğŸ› ï¸ å¼€å‘å·¥å…·é“¾

### 1. IDE æ”¯æŒ

```rust
// VS Code æ’ä»¶é…ç½®
// .vscode/settings.json
{
    "rust-analyzer.procMacro.enable": true,
    "rust-analyzer.procMacro.attributes.enable": true,
    "antd-styles.syntax.highlight": true,
    "antd-styles.autocomplete.enable": true
}

// è¯­æ³•é«˜äº®è§„åˆ™
// syntaxes/antd-styles.tmLanguage.json
{
    "scopeName": "source.rust.antd-styles",
    "patterns": [
        {
            "name": "meta.style.antd",
            "begin": "style!",
            "end": "}",
            "patterns": [
                {
                    "name": "support.type.property-name.css",
                    "match": "\\b[a-z-]+(?=\\s*:)"
                },
                {
                    "name": "string.quoted.double.css",
                    "match": "\\{[^}]+\\}"
                }
            ]
        }
    ]
}
```

### 2. è°ƒè¯•å·¥å…·

```rust
// æ ·å¼è°ƒè¯•å™¨
#[cfg(debug_assertions)]
pub struct StyleDebugger {
    enabled: bool,
    log_level: LogLevel,
}

#[cfg(debug_assertions)]
impl StyleDebugger {
    pub fn log_style_generation(&self, class_name: &str, css: &str) {
        if self.enabled {
            web_sys::console::log_2(
                &format!("[AntD Styles] Generated: {}").into(),
                &css.into()
            );
        }
    }

    pub fn log_theme_change(&self, old_theme: &Theme, new_theme: &Theme) {
        if self.enabled {
            web_sys::console::group_1(&"[AntD Styles] Theme Change".into());
            web_sys::console::log_1(&format!("Old: {:?}", old_theme).into());
            web_sys::console::log_1(&format!("New: {:?}", new_theme).into());
            web_sys::console::group_end();
        }
    }

    pub fn inspect_element_styles(&self, element_id: &str) {
        // æ£€æŸ¥å…ƒç´ çš„æ‰€æœ‰åº”ç”¨æ ·å¼
        let script = format!(
            r#"
            const element = document.getElementById('{}');
            if (element) {{
                const styles = window.getComputedStyle(element);
                console.table(Object.fromEntries(
                    Array.from(styles).map(prop => [prop, styles.getPropertyValue(prop)])
                ));
            }}
            "#,
            element_id
        );

        web_sys::eval(&script).unwrap();
    }
}
```

## ğŸ“Š å®æ–½è·¯çº¿å›¾

### ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€æ¶æ„ï¼ˆ4-6å‘¨ï¼‰

1. **å®ç³»ç»Ÿå¼€å‘**
   - å®ç°åŸºç¡€çš„ `style!` å®
   - CSS è¯­æ³•è§£æå™¨
   - åŸºç¡€çš„æ ·å¼ç”Ÿæˆ

2. **è¿è¡Œæ—¶ç³»ç»Ÿ**
   - æ ·å¼ç®¡ç†å™¨
   - DOM æ“ä½œæ¥å£
   - åŸºç¡€ç¼“å­˜æœºåˆ¶

### ç¬¬äºŒé˜¶æ®µï¼šæ ¸å¿ƒåŠŸèƒ½ï¼ˆ6-8å‘¨ï¼‰

1. **é«˜çº§è¯­æ³•æ”¯æŒ**
   - åµŒå¥—é€‰æ‹©å™¨
   - ä¼ªç±»å’Œä¼ªå…ƒç´ 
   - åª’ä½“æŸ¥è¯¢
   - å˜é‡æ’å€¼

2. **ä¸»é¢˜ç³»ç»Ÿ**
   - Design Token å®šä¹‰
   - ä¸»é¢˜ä¸Šä¸‹æ–‡
   - åŠ¨æ€ä¸»é¢˜åˆ‡æ¢

### ç¬¬ä¸‰é˜¶æ®µï¼šæ€§èƒ½ä¼˜åŒ–ï¼ˆ4-6å‘¨ï¼‰

1. **ç¼–è¯‘æ—¶ä¼˜åŒ–**
   - æ ·å¼é¢„è®¡ç®—
   - æ­»ä»£ç æ¶ˆé™¤
   - æ ·å¼å‹ç¼©

2. **è¿è¡Œæ—¶ä¼˜åŒ–**
   - æ ·å¼ç¼“å­˜
   - å¢é‡æ›´æ–°
   - æ‰¹é‡ DOM æ“ä½œ

### ç¬¬å››é˜¶æ®µï¼šå·¥å…·é“¾å®Œå–„ï¼ˆ3-4å‘¨ï¼‰

1. **å¼€å‘å·¥å…·**
   - IDE æ’ä»¶
   - è°ƒè¯•å·¥å…·
   - æ€§èƒ½åˆ†æå™¨

2. **æ–‡æ¡£å’Œæµ‹è¯•**
   - API æ–‡æ¡£
   - ä½¿ç”¨ç¤ºä¾‹
   - å•å…ƒæµ‹è¯•

## ğŸ¯ æŠ€æœ¯ä¼˜åŠ¿

### 1. ç±»å‹å®‰å…¨
- ç¼–è¯‘æ—¶æ ·å¼æ£€æŸ¥
- ä¸»é¢˜ç±»å‹çº¦æŸ
- å±æ€§å€¼éªŒè¯

### 2. æ€§èƒ½ä¼˜åŠ¿
- ç¼–è¯‘æ—¶ä¼˜åŒ–
- é›¶è¿è¡Œæ—¶å¼€é”€ï¼ˆé™æ€æ ·å¼ï¼‰
- é«˜æ•ˆçš„æ ·å¼ç¼“å­˜

### 3. å¼€å‘ä½“éªŒ
- æ™ºèƒ½ä»£ç è¡¥å…¨
- å®æ—¶é”™è¯¯æ£€æŸ¥
- çƒ­é‡è½½æ”¯æŒ

### 4. ç”Ÿæ€é›†æˆ
- ä¸ Dioxus æ·±åº¦é›†æˆ
- Rust å·¥å…·é“¾æ”¯æŒ
- ç°ä»£åŒ–çš„å¼€å‘æµç¨‹

## ğŸš§ æŠ€æœ¯æŒ‘æˆ˜ä¸è§£å†³æ–¹æ¡ˆ

### 1. å®ç³»ç»Ÿå¤æ‚æ€§
**æŒ‘æˆ˜**ï¼šCSS è¯­æ³•çš„å®Œæ•´è§£æå’Œè½¬æ¢
**è§£å†³æ–¹æ¡ˆ**ï¼š
- ä½¿ç”¨æˆç†Ÿçš„è§£æåº“ï¼ˆå¦‚ lightningcssï¼‰
- æ¸è¿›å¼åŠŸèƒ½å®ç°
- å®Œå–„çš„é”™è¯¯å¤„ç†å’Œæç¤º

### 2. è¿è¡Œæ—¶æ€§èƒ½
**æŒ‘æˆ˜**ï¼šåŠ¨æ€æ ·å¼çš„æ€§èƒ½å¼€é”€
**è§£å†³æ–¹æ¡ˆ**ï¼š
- æ™ºèƒ½ç¼“å­˜ç­–ç•¥
- æ‰¹é‡ DOM æ›´æ–°
- æ ·å¼ diff ç®—æ³•

### 3. å¼€å‘å·¥å…·æ”¯æŒ
**æŒ‘æˆ˜**ï¼šIDE é›†æˆçš„å¤æ‚æ€§
**è§£å†³æ–¹æ¡ˆ**ï¼š
- ä¸ rust-analyzer é›†æˆ
- è‡ªå®šä¹‰è¯­è¨€æœåŠ¡å™¨
- æ¸è¿›å¼åŠŸèƒ½å¢å¼º

è¿™ä¸ª CSS-in-Rust è‡ªç ”æ–¹æ¡ˆä¸º Ant Design Dioxus é¡¹ç›®æä¾›äº†å®Œå…¨è‡ªä¸»å¯æ§ã€é«˜æ€§èƒ½ã€ç±»å‹å®‰å…¨çš„æ ·å¼è§£å†³æ–¹æ¡ˆï¼Œå……åˆ†å‘æŒ¥äº† Rust è¯­è¨€çš„ä¼˜åŠ¿ï¼ŒåŒæ—¶ä¿æŒäº†ç°ä»£å‰ç«¯å¼€å‘çš„ä¾¿åˆ©æ€§ã€‚
